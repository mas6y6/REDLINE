use crate::ast::{Program, Statement, Expression, Literal};
use std::fmt;

/// Represents an error encountered during code generation.
#[derive(Debug)]
pub struct CodegenError {
    pub message: String,
}

impl fmt::Display for CodegenError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Codegen Error: {}", self.message)
    }
}

pub fn generate(program: &Program) -> Result<String, CodegenError> {
    let mut cpp_code = String::new();

    let includes = String::from(
        "// Generated by REDLINE Core\n#include \"stdlib/rl_io.hpp\"\n#include \"stdlib/rl_math.hpp\"\n#include <string>\n\nusing namespace rl;\n\n",
    );
    cpp_code.push_str(&includes);

    let mut functions = Vec::new();
    let mut main_statements = Vec::new();

    for stmt in &program.statements {
        if let Statement::FunctionDefinition { .. } = stmt {
            functions.push(stmt.clone());
        } else {
            main_statements.push(stmt.clone());
        }
    }

    let mut forward_declarations = String::new();
    for func in &functions {
        if let Statement::FunctionDefinition { name, params, return_type, .. } = func {
             let param_str: Vec<String> = params.iter()
                .map(|(n, t)| format!("{} {}", t.to_string(), n))
                .collect();
             forward_declarations.push_str(&format!("{} {}({});\n", return_type.to_string(), name, param_str.join(", ")));
        }
    }
    if !forward_declarations.is_empty() {
        forward_declarations.push('\n');
    }
    cpp_code.push_str(&forward_declarations);

    let mut function_definitions = String::new();
    for func in &functions {
        function_definitions.push_str(&generate_statement(func, 0)?);
        function_definitions.push('\n');
    }
    cpp_code.push_str(&function_definitions);

    let main_body = generate_block(&main_statements, 1)?;

    cpp_code.push_str("int main() {\n");
    cpp_code.push_str(&main_body);
    cpp_code.push_str("    return 0;\n}\n");

    Ok(cpp_code)
}

fn generate_block(statements: &[Statement], indent_level: usize) -> Result<String, CodegenError> {
    let mut block_code = String::new();
    for statement in statements {
        block_code.push_str(&generate_statement(statement, indent_level)?);
    }
    Ok(block_code)
}

fn generate_statement(statement: &Statement, indent_level: usize) -> Result<String, CodegenError> {
    let indent = "    ".repeat(indent_level);
    let mut statement_code = String::new();

    match statement {
        Statement::Declaration { is_mutable, name, data_type, initializer } => {
            let prefix = if *is_mutable { "" } else { "const " };
            let cpp_type = data_type.to_string();
            let initial_value = generate_expression(initializer)?;
            statement_code.push_str(&format!("{}{}{} {} = {};\n", indent, prefix, cpp_type, name, initial_value));
        },
        Statement::Assignment { name, value } => {
            let value_str = generate_expression(value)?;
            statement_code.push_str(&format!("{}{} = {};\n", indent, name, value_str));
        },
        Statement::If { condition, consequence, alternative } => {
            let cond_str = generate_expression(condition)?;
            statement_code.push_str(&format!("{}if ({}) {{\n", indent, cond_str));
            statement_code.push_str(&generate_block(consequence, indent_level + 1)?);
            statement_code.push_str(&format!("{}}}\n", indent));

            if let Some(alt_statements) = alternative {
                statement_code.push_str(&format!("{}else {{\n", indent));
                statement_code.push_str(&generate_block(alt_statements, indent_level + 1)?);
                statement_code.push_str(&format!("{}}}\n", indent));
            }
        },
        Statement::While { condition, body } => {
            let cond_str = generate_expression(condition)?;
            statement_code.push_str(&format!("{}while ({}) {{\n", indent, cond_str));
            statement_code.push_str(&generate_block(body, indent_level + 1)?);
            statement_code.push_str(&format!("{}}}\n", indent));
        },
        Statement::For { iterator, start, end, body } => {
            let start_str = generate_expression(start)?;
            let end_str = generate_expression(end)?;
            statement_code.push_str(&format!("{}for (int {} = {}; {} < {}; ++{}) {{\n",
                indent, iterator, start_str, iterator, end_str, iterator));
            statement_code.push_str(&generate_block(body, indent_level + 1)?);
            statement_code.push_str(&format!("{}}}\n", indent));
        },
        Statement::Print(expr) => {
            let arg_str = generate_expression(expr)?;
            statement_code.push_str(&format!("{}rl::print({});\n", indent, arg_str));
        },
        Statement::Expression(expr) => {
            let expr_str = generate_expression(expr)?;
            statement_code.push_str(&format!("{}{};\n", indent, expr_str));
        },
        Statement::FunctionDefinition { name, params, return_type, body } => {
            let param_str: Vec<String> = params.iter()
                .map(|(param_name, param_type)| format!("{} {}", param_type.to_string(), param_name))
                .collect();
            statement_code.push_str(&format!("{}{} {}({}) {{\n", indent, return_type.to_string(), name, param_str.join(", ")));
            statement_code.push_str(&generate_block(body, indent_level + 1)?);
            statement_code.push_str(&format!("{}}}\n", indent));
        },
        Statement::Return(expr) => {
            match expr {
                Some(e) => {
                    let expr_str = generate_expression(e)?;
                    statement_code.push_str(&format!("{}return {};\n", indent, expr_str));
                },
                None => {
                    statement_code.push_str(&format!("{}return;\n", indent));
                }
            }
        },
    }
    Ok(statement_code)
}

fn generate_expression(expr: &Expression) -> Result<String, CodegenError> {
    match expr {
        Expression::Literal(Literal::Int(n)) => Ok(n.to_string()),
        Expression::Literal(Literal::Float(n)) => Ok(n.to_string()),
        Expression::Literal(Literal::String(s)) => Ok(format!("\"{}\"", s)),
        Expression::Literal(Literal::Bool(b)) => Ok(if *b { "true".to_string() } else { "false".to_string() }),
        Expression::Identifier(name) => Ok(name.clone()),
        Expression::Call(name, args) => {
            let args_str: Result<Vec<String>, CodegenError> = args.iter()
                .map(|arg| generate_expression(arg))
                .collect();
            let args_str = args_str?;

            // Handle built-in functions that are not print
            match name.as_str() {
                "input" => Ok(format!("rl::input({})", args_str.join(", "))),
                "to_int" => Ok(format!("std::stoi({})", args_str.join(", "))),
                "to_float" => Ok(format!("std::stod({})", args_str.join(", "))),
                "to_string" => Ok(format!("std::to_string({})", args_str.join(", "))),
                // Default to a regular function call
                _ => Ok(format!("{}({})", name, args_str.join(", "))),
            }
        },
        Expression::BinaryOp { op, left, right } => {
            let left_str = generate_expression(left)?;
            let right_str = generate_expression(right)?;
            Ok(format!("({} {} {})", left_str, op.to_string(), right_str))
        },
    }
}
