use crate::ast::{Program, Statement, Expression, Literal, ClassMember, Type};
use std::fmt;
use std::path::Path;

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum GenMode {
    Hpp,
    Cpp,
}

#[derive(Debug)]
pub struct CodegenError {
    pub message: String,
}

impl fmt::Display for CodegenError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Codegen Error: {}", self.message)
    }
}

pub fn generate(program: &Program, mode: GenMode, module_name: &str) -> Result<String, CodegenError> {
    if mode == GenMode::Hpp {
        return generate_hpp(program, module_name);
    }

    // --- C++ Generation ---
    let mut cpp_code = String::new();
    let has_main = program.statements.iter().any(|s| !matches!(s, Statement::FunctionDefinition { .. } | Statement::Import(_) | Statement::Class { .. }));

    // Includes
    let mut includes = format!("// Generated by REDLINE Core for module {}\n", module_name);
    if has_main {
        includes.push_str("#include <iostream>\n");
    }
    includes.push_str("#include <memory>\n"); // For std::shared_ptr
    includes.push_str("#include <map>\n"); // For std::map
    includes.push_str(&format!("#include \"{}.hpp\"\n", module_name));
    for stmt in &program.statements {
        if let Statement::Import(path) = stmt {
            let imported_module_name = Path::new(path).file_stem().unwrap().to_str().unwrap();
            includes.push_str(&format!("#include \"{}.hpp\"\n", imported_module_name));
        }
    }
    cpp_code.push_str(&includes);

    // Global variable definition for main module
    if has_main {
        cpp_code.push_str("\nstd::vector<std::string> rl::args;\n");
    }

    // Implementations
    cpp_code.push_str("\nnamespace rl {\n\n");
    for stmt in &program.statements {
        match stmt {
            Statement::FunctionDefinition { .. } => {
                cpp_code.push_str(&generate_statement(stmt, 0, mode, None)?);
                cpp_code.push_str("\n");
            }
            Statement::Class { name, members, .. } => {
                for member in members {
                    match member {
                        ClassMember::Method(method_stmt) => {
                            cpp_code.push_str(&generate_statement(method_stmt, 0, mode, Some(name))?);
                            cpp_code.push_str("\n");
                        }
                        ClassMember::Constructor(constructor_stmt) => {
                            cpp_code.push_str(&generate_statement(constructor_stmt, 0, mode, Some(name))?);
                            cpp_code.push_str("\n");
                        }
                        _ => {}
                    }
                }
            }
            _ => {}
        }
    }
    cpp_code.push_str("\n} // namespace rl\n");

    // Main Function
    if has_main {
        cpp_code.push_str("\nint main(int argc, char* argv[]) {\n");
        cpp_code.push_str("    rl::args.assign(argv, argv + argc);\n");
        cpp_code.push_str("    std::ios_base::sync_with_stdio(false);\n");
        cpp_code.push_str("    std::cin.tie(NULL);\n\n");
        cpp_code.push_str("    using namespace rl;\n");
        let main_body = generate_block(&program.statements, 1, mode)?;
        cpp_code.push_str(&main_body);
        cpp_code.push_str("    return 0;\n}\n");
    }

    Ok(cpp_code)
}

fn generate_hpp(program: &Program, module_name: &str) -> Result<String, CodegenError> {
    let mut hpp_code = String::new();
    let guard = format!("RL_{}_H", module_name.to_uppercase());

    hpp_code.push_str(&format!("#ifndef {}\n#define {}\n\n", guard, guard));
    hpp_code.push_str("#include <memory>\n"); // For std::shared_ptr
    hpp_code.push_str("#include <map>\n"); // For std::map
    hpp_code.push_str("#include \"stdlib/rl_io.hpp\"\n");
    hpp_code.push_str("#include \"stdlib/rl_math.hpp\"\n");
    hpp_code.push_str("#include \"stdlib/rl_stdlib.hpp\"\n");
    hpp_code.push_str("#include \"stdlib/rl_file.hpp\"\n");
    hpp_code.push_str("#include \"stdlib/rl_string.hpp\"\n");
    hpp_code.push_str("#include \"stdlib/rl_random.hpp\"\n");
    hpp_code.push_str("#include \"stdlib/rl_time.hpp\"\n");
    hpp_code.push_str("#include <string>\n#include <vector>\n\n");
    hpp_code.push_str("namespace rl {\n\n");

    for stmt in &program.statements {
        if let Statement::Class { name, members, .. } = stmt {
            hpp_code.push_str(&format!("class {} {{\n", name));
            hpp_code.push_str("public:\n");
            for member in members {
                match member {
                    ClassMember::Variable(Statement::Declaration { name, data_type, initializer, .. }) => {
                        let initial_value = generate_expression(initializer)?;
                        hpp_code.push_str(&format!("    {} {} = {};\n", data_type.to_string(), name, initial_value));
                    }
                    ClassMember::Method(Statement::FunctionDefinition { name, params, return_type, .. }) => {
                        let param_str: Vec<String> = params.iter().map(|(n, t)| format!("{} {}", t.to_string(), n)).collect();
                        hpp_code.push_str(&format!("    {} {}({});\n", return_type.to_string(), name, param_str.join(", ")));
                    }
                    ClassMember::Constructor(Statement::FunctionDefinition { params, .. }) => {
                        let param_str: Vec<String> = params.iter().map(|(n, t)| format!("{} {}", t.to_string(), n)).collect();
                        hpp_code.push_str(&format!("    {}({});\n", name, param_str.join(", ")));
                    }
                    _ => {}
                }
            }
            hpp_code.push_str("};\n\n");
        }
        if let Statement::FunctionDefinition { is_public: true, name, params, return_type, .. } = stmt {
            let param_str: Vec<String> = params.iter().map(|(n, t)| format!("{} {}", t.to_string(), n)).collect();
            hpp_code.push_str(&format!("{} {}({});\n", return_type.to_string(), name, param_str.join(", ")));
        }
    }

    hpp_code.push_str("\n} // namespace rl\n");
    hpp_code.push_str(&format!("\n#endif // {}\n", guard));
    Ok(hpp_code)
}

fn generate_block(statements: &[Statement], indent_level: usize, mode: GenMode) -> Result<String, CodegenError> {
    let mut block_code = String::new();
    for statement in statements {
        if !matches!(statement, Statement::FunctionDefinition{..} | Statement::Import(_) | Statement::Class{..}) {
            block_code.push_str(&generate_statement(statement, indent_level, mode, None)?);
        }
    }
    Ok(block_code)
}

fn generate_statement(statement: &Statement, indent_level: usize, mode: GenMode, class_scope: Option<&str>) -> Result<String, CodegenError> {
    let indent = "    ".repeat(indent_level);
    match statement {
        Statement::Declaration { name, data_type, initializer, .. } => {
            let type_str = match data_type {
                Type::Class(class_name) => format!("std::shared_ptr<{}>", class_name),
                Type::Dict(key, value) => format!("std::map<{}, {}>", key.to_string(), value.to_string()),
                _ => data_type.to_string(),
            };
            Ok(format!("{}{} {} = {};\n", indent, type_str, name, generate_expression(initializer)?))
        },
        Statement::FunctionDefinition { name, params, return_type, body, .. } => {
            let param_str: Vec<String> = params.iter().map(|(p_name, p_type)| format!("{} {}", p_type.to_string(), p_name)).collect();
            let mut func_def = String::new();
            if let Some(class_name) = class_scope {
                if name == "init" {
                    func_def.push_str(&format!("{}::{}({}) {{\n", class_name, class_name, param_str.join(", ")));
                } else {
                    func_def.push_str(&format!("{} {}::{}({}) {{\n", return_type.to_string(), class_name, name, param_str.join(", ")));
                }
            } else {
                func_def.push_str(&format!("{} {}({}) {{\n", return_type.to_string(), name, param_str.join(", ")));
            }
            func_def.push_str(&generate_block(body, indent_level + 1, mode)?);
            func_def.push_str(&format!("{}}}\n", indent));
            Ok(func_def)
        },
        Statement::Assignment { target, value } => Ok(format!("{}{} = {};\n", indent, generate_expression(target)?, generate_expression(value)?)),
        Statement::Print(expr) => Ok(format!("{}print({});\n", indent, generate_expression(expr)?)),
        Statement::Expression(expr) => Ok(format!("{}{};\n", indent, generate_expression(expr)?)),
        Statement::Return(expr) => {
            if let Some(e) = expr {
                Ok(format!("{}return {};\n", indent, generate_expression(e)?))
            } else {
                Ok(format!("{}return;\n", indent))
            }
        },
        Statement::If { condition, consequence, alternative } => {
            let cond_str = generate_expression(condition)?;
            let mut code = format!("{}if ({}) {{\n", indent, cond_str);
            code.push_str(&generate_block(consequence, indent_level + 1, mode)?);
            code.push_str(&format!("{}}}\n", indent));
            if let Some(alt) = alternative {
                code.push_str(&format!("{}else {{\n", indent));
                code.push_str(&generate_block(alt, indent_level + 1, mode)?);
                code.push_str(&format!("{}}}\n", indent));
            }
            Ok(code)
        },
        Statement::While { condition, body } => {
            let cond_str = generate_expression(condition)?;
            let mut code = format!("{}while ({}) {{\n", indent, cond_str);
            code.push_str(&generate_block(body, indent_level + 1, mode)?);
            code.push_str(&format!("{}}}\n", indent));
            Ok(code)
        },
        Statement::For { iterator, start, end, body } => {
            let start_str = generate_expression(start)?;
            let end_str = generate_expression(end)?;
            let mut code = format!("{}for (int {} = {}; {} < {}; ++{}) {{\n", indent, iterator, start_str, iterator, end_str, iterator);
            code.push_str(&generate_block(body, indent_level + 1, mode)?);
            code.push_str(&format!("{}}}\n", indent));
            Ok(code)
        },
        Statement::TryCatch { try_block, catch_var, catch_block } => {
            let mut code = format!("{}try {{\n", indent);
            code.push_str(&generate_block(try_block, indent_level + 1, mode)?);
            code.push_str(&format!("{}}} catch (const std::exception& {}) {{\n", indent, catch_var));
            code.push_str(&generate_block(catch_block, indent_level + 1, mode)?);
            code.push_str(&format!("{}}}\n", indent));
            Ok(code)
        },
        Statement::Break => Ok(format!("{}break;\n", indent)),
        Statement::Continue => Ok(format!("{}continue;\n", indent)),
        _ => Ok("".to_string())
    }
}

fn generate_expression(expr: &Expression) -> Result<String, CodegenError> {
    match expr {
        Expression::New { class_name, args } => {
            let args_str: Result<Vec<String>, _> = args.iter().map(generate_expression).collect();
            Ok(format!("std::make_shared<{}>({})", class_name, args_str?.join(", ")))
        },
        Expression::This => Ok("this".to_string()),
        Expression::Get { object, name } => {
            Ok(format!("{}->{}", generate_expression(object)?, name))
        }
        Expression::Identifier(name) => {
            match name.as_str() {
                "to_string" => Ok("rl::to_string".to_string()),
                "to_int" => Ok("std::stoi".to_string()),
                "to_float" => Ok("std::stod".to_string()),
                "read_file" => Ok("rl::read_file".to_string()),
                "write_file" => Ok("rl::write_file".to_string()),
                "split" => Ok("rl::split".to_string()),
                "join" => Ok("rl::join".to_string()),
                "contains" => Ok("rl::contains".to_string()),
                "args" => Ok("rl::args".to_string()),
                "exists" => Ok("rl::exists".to_string()),
                "remove" => Ok("rl::remove".to_string()),
                "list_dir" => Ok("rl::list_dir".to_string()),
                "mkdir" => Ok("rl::mkdir".to_string()),
                "random_int" => Ok("rl::random_int".to_string()),
                "random_float" => Ok("rl::random_float".to_string()),
                "time" => Ok("rl::time".to_string()),
                "sleep" => Ok("rl::sleep".to_string()),
                _ => Ok(name.clone()),
            }
        }
        Expression::Call { callee, args } => {
            let callee_str = generate_expression(callee)?;
            let args_str: Result<Vec<String>, _> = args.iter().map(generate_expression).collect();
            Ok(format!("{}({})", callee_str, args_str?.join(", ")))
        },
        Expression::Literal(Literal::Int(n)) => Ok(n.to_string()),
        Expression::Literal(Literal::Float(n)) => Ok(n.to_string()),
        Expression::Literal(Literal::String(s)) => Ok(format!("\"{}\"", s)),
        Expression::Literal(Literal::Bool(b)) => Ok(if *b { "true".to_string() } else { "false".to_string() }),
        Expression::Index { list, index } => Ok(format!("{}.at({})", generate_expression(list)?, generate_expression(index)?)),
        Expression::BinaryOp { op, left, right } => Ok(format!("({} {} {})", generate_expression(left)?, op.to_string(), generate_expression(right)?)),
        Expression::ListLiteral(elements) => {
            let elems: Result<Vec<String>, _> = elements.iter().map(generate_expression).collect();
            Ok(format!("{{ {} }}", elems?.join(", ")))
        },
        Expression::DictLiteral(entries) => {
            let mut entry_strs = Vec::new();
            for (key, value) in entries {
                entry_strs.push(format!("{{{}, {}}}", generate_expression(key)?, generate_expression(value)?));
            }
            Ok(format!("{{ {} }}", entry_strs.join(", ")))
        }
    }
}
