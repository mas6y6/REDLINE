use crate::ast::{Program, Statement, Expression, Literal, Type, BinaryOperator};
use std::fmt;

#[derive(Debug)]
pub struct CodegenError {
    pub message: String,
}

impl fmt::Display for CodegenError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Codegen Error: {}", self.message)
    }
}

// Helper to generate C++ code for an expression
fn generate_expression(expr: &Expression) -> Result<String, CodegenError> {
    match expr {
        Expression::Literal(Literal::Int(n)) => Ok(n.to_string()),
        Expression::Literal(Literal::String(s)) => Ok(format!("\"{}\"", s)),
        Expression::Identifier(name) => Ok(name.clone()),
        Expression::BinaryOp { op, left, right } => {
            let left_str = generate_expression(left)?;
            let right_str = generate_expression(right)?;
            Ok(format!("({} {} {})", left_str, op.to_string(), right_str))
        },
        _ => Err(CodegenError { message: format!("Unsupported expression for codegen: {:?}", expr) }),
    }
}

// Helper to generate C++ code for a block of statements
fn generate_block(statements: &[Statement], indent_level: usize) -> Result<String, CodegenError> {
    let mut block_code = String::new();
    let indent = "    ".repeat(indent_level);

    for statement in statements {
        match statement {
            Statement::Declaration { is_mutable, name, data_type, initializer } => {
                let prefix = if *is_mutable { "" } else { "const " };
                let cpp_type = data_type.to_string();
                let initial_value = generate_expression(initializer)?;
                block_code.push_str(&format!("{}{}{} {} = {};\n", indent, prefix, cpp_type, name, initial_value));
            },
            Statement::If { condition, consequence, alternative } => {
                let cond_str = generate_expression(condition)?;
                block_code.push_str(&format!("{}if ({}) {{\n", indent, cond_str));
                block_code.push_str(&generate_block(consequence, indent_level + 1)?);
                block_code.push_str(&format!("{}}}\n", indent));

                if let Some(alt_statements) = alternative {
                    block_code.push_str(&format!("{}else {{\n", indent));
                    block_code.push_str(&generate_block(alt_statements, indent_level + 1)?);
                    block_code.push_str(&format!("{}}}\n", indent));
                }
            },
            Statement::Print(expr) => {
                let arg_str = generate_expression(expr)?;
                block_code.push_str(&format!("{}rl::print({});\n", indent, arg_str));
            },
            _ => return Err(CodegenError { message: format!("Unsupported statement for codegen: {:?}", statement) }),
        }
    }
    Ok(block_code)
}


pub fn generate(program: &Program) -> Result<String, CodegenError> {
    let mut cpp_code = String::new();
    let includes = String::from(
        "// Generated by REDLINE Core\n#include \"stdlib/rl_io.hpp\"\n#include <string>\n\n",
    );
    let mut main_body = String::new();

    main_body.push_str(&generate_block(&program.statements, 1)?); // Initial indent for main body


    cpp_code.push_str(&includes);
    cpp_code.push_str("int main() {\n");
    cpp_code.push_str(&main_body);
    cpp_code.push_str("    return 0;\n}\n");

    Ok(cpp_code)
}
