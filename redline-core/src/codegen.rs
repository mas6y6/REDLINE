use crate::ast::{Program, Statement, Expression, Literal, ClassMember};
use std::fmt;
use std::path::Path;

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum GenMode {
    Hpp,
    Cpp,
}

#[derive(Debug)]
pub struct CodegenError {
    pub message: String,
}

impl fmt::Display for CodegenError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Codegen Error: {}", self.message)
    }
}

pub fn generate(program: &Program, mode: GenMode, module_name: &str) -> Result<String, CodegenError> {
    if mode == GenMode::Hpp {
        return generate_hpp(program, module_name);
    }

    // --- C++ Generation ---
    let mut cpp_code = String::new();
    let has_main = program.statements.iter().any(|s| !matches!(s, Statement::FunctionDefinition { .. } | Statement::Import(_) | Statement::Class { .. }));

    // Includes
    let mut includes = format!("// Generated by REDLINE Core for module {}\n", module_name);
    if has_main {
        includes.push_str("#include <iostream>\n");
    }
    includes.push_str(&format!("#include \"{}.hpp\"\n", module_name));
    for stmt in &program.statements {
        if let Statement::Import(path) = stmt {
            let imported_module_name = Path::new(path).file_stem().unwrap().to_str().unwrap();
            includes.push_str(&format!("#include \"{}.hpp\"\n", imported_module_name));
        }
    }
    cpp_code.push_str(&includes);

    // Implementations
    cpp_code.push_str("\nnamespace rl {\n\n");
    for stmt in &program.statements {
        match stmt {
            Statement::FunctionDefinition { .. } => {
                cpp_code.push_str(&generate_statement(stmt, 0, mode, None)?);
                cpp_code.push_str("\n");
            }
            Statement::Class { name, members } => {
                for member in members {
                    if let ClassMember::Method(method_stmt) = member {
                        cpp_code.push_str(&generate_statement(method_stmt, 0, mode, Some(name))?);
                        cpp_code.push_str("\n");
                    }
                }
            }
            _ => {}
        }
    }
    cpp_code.push_str("\n} // namespace rl\n");

    // Main Function
    if has_main {
        cpp_code.push_str("\nint main() {\n");
        cpp_code.push_str("    std::ios_base::sync_with_stdio(false);\n");
        cpp_code.push_str("    std::cin.tie(NULL);\n\n");
        cpp_code.push_str("    using namespace rl;\n");
        let main_body = generate_block(&program.statements, 1, mode)?;
        cpp_code.push_str(&main_body);
        cpp_code.push_str("    return 0;\n}\n");
    }

    Ok(cpp_code)
}

fn generate_hpp(program: &Program, module_name: &str) -> Result<String, CodegenError> {
    let mut hpp_code = String::new();
    let guard = format!("RL_{}_H", module_name.to_uppercase());

    hpp_code.push_str(&format!("#ifndef {}\n#define {}\n\n", guard, guard));
    hpp_code.push_str("#include \"stdlib/rl_io.hpp\"\n");
    hpp_code.push_str("#include \"stdlib/rl_math.hpp\"\n");
    hpp_code.push_str("#include \"stdlib/rl_stdlib.hpp\"\n");
    hpp_code.push_str("#include <string>\n#include <vector>\n\n");
    hpp_code.push_str("namespace rl {\n\n");

    for stmt in &program.statements {
        if let Statement::Class { name, members } = stmt {
            hpp_code.push_str(&format!("class {} {{\n", name));
            hpp_code.push_str("public:\n"); // Simplified: all members are public for now
            for member in members {
                match member {
                    ClassMember::Variable(Statement::Declaration { name, data_type, .. }) => {
                        hpp_code.push_str(&format!("    {} {};\n", data_type.to_string(), name));
                    }
                    ClassMember::Method(Statement::FunctionDefinition { name, params, return_type, .. }) => {
                        let param_str: Vec<String> = params.iter().map(|(n, t)| format!("{} {}", t.to_string(), n)).collect();
                        hpp_code.push_str(&format!("    {} {}({});\n", return_type.to_string(), name, param_str.join(", ")));
                    }
                    _ => {}
                }
            }
            hpp_code.push_str("};\n\n");
        }
        // Handle standalone public functions
        if let Statement::FunctionDefinition { is_public: true, name, params, return_type, .. } = stmt {
            let param_str: Vec<String> = params.iter().map(|(n, t)| format!("{} {}", t.to_string(), n)).collect();
            hpp_code.push_str(&format!("{} {}({});\n", return_type.to_string(), name, param_str.join(", ")));
        }
    }

    hpp_code.push_str("\n} // namespace rl\n");
    hpp_code.push_str(&format!("\n#endif // {}\n", guard));
    Ok(hpp_code)
}

fn generate_block(statements: &[Statement], indent_level: usize, mode: GenMode) -> Result<String, CodegenError> {
    let mut block_code = String::new();
    for statement in statements {
        if !matches!(statement, Statement::FunctionDefinition{..} | Statement::Import(_) | Statement::Class{..}) {
            block_code.push_str(&generate_statement(statement, indent_level, mode, None)?);
        }
    }
    Ok(block_code)
}

fn generate_statement(statement: &Statement, indent_level: usize, mode: GenMode, class_scope: Option<&str>) -> Result<String, CodegenError> {
    let indent = "    ".repeat(indent_level);
    match statement {
        Statement::Declaration { name, data_type, initializer, .. } => {
            Ok(format!("{}{} {} = {};\n", indent, data_type.to_string(), name, generate_expression(initializer)?))
        },
        Statement::FunctionDefinition { name, params, return_type, body, .. } => {
            let param_str: Vec<String> = params.iter().map(|(p_name, p_type)| format!("{} {}", p_type.to_string(), p_name)).collect();
            let mut func_def = String::new();
            if let Some(class_name) = class_scope {
                func_def.push_str(&format!("{} {}::{}({}) {{\n", return_type.to_string(), class_name, name, param_str.join(", ")));
            } else {
                func_def.push_str(&format!("{} {}({}) {{\n", return_type.to_string(), name, param_str.join(", ")));
            }
            func_def.push_str(&generate_block(body, indent_level + 1, mode)?);
            func_def.push_str(&format!("{}}}\n", indent));
            Ok(func_def)
        },
        Statement::Assignment { target, value } => Ok(format!("{}{} = {};\n", indent, generate_expression(target)?, generate_expression(value)?)),
        Statement::Print(expr) => Ok(format!("{}print({});\n", indent, generate_expression(expr)?)),
        Statement::Expression(expr) => Ok(format!("{}{};\n", indent, generate_expression(expr)?)),
        Statement::Return(expr) => {
            if let Some(e) = expr {
                Ok(format!("{}return {};\n", indent, generate_expression(e)?))
            } else {
                Ok(format!("{}return;\n", indent))
            }
        },
        _ => Ok("".to_string())
    }
}

fn generate_expression(expr: &Expression) -> Result<String, CodegenError> {
    match expr {
        Expression::This => Ok("this".to_string()),
        Expression::Get { object, name } => {
            if let Expression::This = **object {
                Ok(format!("this->{}", name))
            } else {
                Ok(format!("{}.{}", generate_expression(object)?, name))
            }
        }
        Expression::Identifier(name) => Ok(name.clone()),
        Expression::Call { callee, args } => {
            let callee_str = generate_expression(callee)?;
            let args_str: Result<Vec<String>, _> = args.iter().map(generate_expression).collect();
            Ok(format!("{}({})", callee_str, args_str?.join(", ")))
        },
        // Other expressions
        Expression::Literal(Literal::Int(n)) => Ok(n.to_string()),
        Expression::Literal(Literal::Float(n)) => Ok(n.to_string()),
        Expression::Literal(Literal::String(s)) => Ok(format!("\"{}\"", s)),
        Expression::Literal(Literal::Bool(b)) => Ok(if *b { "true".to_string() } else { "false".to_string() }),
        Expression::Index { list, index } => Ok(format!("{}[{}]", generate_expression(list)?, generate_expression(index)?)),
        Expression::BinaryOp { op, left, right } => Ok(format!("({} {} {})", generate_expression(left)?, op.to_string(), generate_expression(right)?)),
        Expression::ListLiteral(elements) => {
            let elems: Result<Vec<String>, _> = elements.iter().map(generate_expression).collect();
            Ok(format!("{{ {} }}", elems?.join(", ")))
        }
    }
}
