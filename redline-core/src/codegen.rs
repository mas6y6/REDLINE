use crate::ast::{Program, Statement, Expression, Literal};
use std::fmt;

#[derive(Debug)]
pub struct CodegenError {
    pub message: String,
}

impl fmt::Display for CodegenError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Codegen Error: {}", self.message)
    }
}

// Helper to generate C++ code for an expression
fn generate_expression(expr: &Expression) -> Result<String, CodegenError> {
    match expr {
        Expression::Literal(Literal::Int(n)) => Ok(n.to_string()),
        Expression::Literal(Literal::Float(n)) => Ok(n.to_string()),
        Expression::Literal(Literal::String(s)) => Ok(format!("\"{}\"", s)),
        Expression::Identifier(name) => Ok(name.clone()),
        Expression::Call(name, args) => {
            let args_str: Result<Vec<String>, CodegenError> = args.iter()
                .map(|arg| generate_expression(arg))
                .collect();
            let args_str = args_str?;
            Ok(format!("{}({})", name, args_str.join(", ")))
        },
        Expression::BinaryOp { op, left, right } => {
            let left_str = generate_expression(left)?;
            let right_str = generate_expression(right)?;
            Ok(format!("({} {} {})", left_str, op.to_string(), right_str))
        },
        // _ => Err(CodegenError { message: format!("Unsupported expression for codegen: {:?}", expr) }),
    }
}

// Helper to generate C++ code for a block of statements
fn generate_block(statements: &[Statement], indent_level: usize) -> Result<String, CodegenError> {
    let mut block_code = String::new();
    let indent = "    ".repeat(indent_level);

    for statement in statements {
        match statement {
            Statement::Declaration { is_mutable, name, data_type, initializer } => {
                let prefix = if *is_mutable { "" } else { "const " };
                let cpp_type = data_type.to_string();
                let initial_value = generate_expression(initializer)?;
                block_code.push_str(&format!("{}{}{} {} = {};\n", indent, prefix, cpp_type, name, initial_value));
            },
            Statement::If { condition, consequence, alternative } => {
                let cond_str = generate_expression(condition)?;
                block_code.push_str(&format!("{}if ({}) {{\n", indent, cond_str));
                block_code.push_str(&generate_block(consequence, indent_level + 1)?);
                block_code.push_str(&format!("{}}}\n", indent));

                if let Some(alt_statements) = alternative {
                    block_code.push_str(&format!("{}else {{\n", indent));
                    block_code.push_str(&generate_block(alt_statements, indent_level + 1)?);
                    block_code.push_str(&format!("{}}}\n", indent));
                }
            },
            Statement::Print(expr) => {
                let arg_str = generate_expression(expr)?;
                block_code.push_str(&format!("{}rl::print({});\n", indent, arg_str));
            },
            Statement::FunctionDefinition { name, params, return_type, body } => {
                let param_str: Vec<String> = params.iter()
                    .map(|(param_name, param_type)| format!("{} {}", param_type.to_string(), param_name))
                    .collect();
                block_code.push_str(&format!("{}{} {}({}) {{\n", indent, return_type.to_string(), name, param_str.join(", ")));
                block_code.push_str(&generate_block(body, indent_level + 1)?);
                block_code.push_str(&format!("{}}}\n", indent));
            },
            Statement::Return(expr) => {
                match expr {
                    Some(e) => {
                        let expr_str = generate_expression(e)?;
                        block_code.push_str(&format!("{}return {};\n", indent, expr_str));
                    },
                    None => {
                        block_code.push_str(&format!("{}return;\n", indent));
                    }
                }
            },
            // _ => return Err(CodegenError { message: format!("Unsupported statement for codegen: {:?}", statement) }),
        }
    }
    Ok(block_code)
}


pub fn generate(program: &Program) -> Result<String, CodegenError> {
    let mut cpp_code = String::new();
    let includes = String::from(
        "// Generated by REDLINE Core\n#include \"stdlib/rl_io.hpp\"\n#include \"stdlib/rl_math.hpp\"\n#include <string>\n\nusing namespace rl;\n\n",
    );

    let mut global_code = String::new();
    let mut main_body = String::new();

    let mut functions = Vec::new();
    let mut main_statements = Vec::new();

    // Separate functions from other statements
    for stmt in &program.statements {
        if let Statement::FunctionDefinition { .. } = stmt {
            functions.push(stmt);
        } else {
            main_statements.push(stmt);
        }
    }

    // 1. Generate Forward Declarations
    for func in &functions {
        if let Statement::FunctionDefinition { name, params, return_type, .. } = func {
             let param_str: Vec<String> = params.iter()
                .map(|(n, t)| format!("{} {}", t.to_string(), n))
                .collect();
             global_code.push_str(&format!("{} {}({});\n", return_type.to_string(), name, param_str.join(", ")));
        }
    }
    if !functions.is_empty() {
        global_code.push_str("\n");
    }

    // 2. Generate Function Definitions
    for func in &functions {
        global_code.push_str(&generate_block(std::slice::from_ref(*func), 0)?);
        global_code.push_str("\n");
    }

    // 3. Generate Main Body
    // Fix: Dereference the references in the vector to get a slice of Statements
    let main_statements_owned: Vec<Statement> = main_statements.into_iter().cloned().collect();
    main_body.push_str(&generate_block(&main_statements_owned, 1)?);

    cpp_code.push_str(&includes);
    cpp_code.push_str(&global_code);
    cpp_code.push_str("int main() {\n");
    cpp_code.push_str(&main_body);
    cpp_code.push_str("    return 0;\n}\n");

    Ok(cpp_code)
}
