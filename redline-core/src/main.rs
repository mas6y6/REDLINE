use std::fs;
use std::env;

#[derive(Debug, Clone, PartialEq)]
enum Token {
    Var, Val, Def, Pub, Print, Return, If, Else,
    Ident(String), Int(i64), Str(String), Type(String),
    Op(String), Arrow, Colon, Assign, LParen, RParen, Comma, Newline,
}

struct Lexer { input: Vec<char>, pos: usize }

impl Lexer {
    fn new(input: String) -> Self { Self { input: input.chars().collect(), pos: 0 } }
    fn tokenize(&mut self) -> Vec<Token> {
        let mut tokens = Vec::new();
        while self.pos < self.input.len() {
            let c = self.input[self.pos];
            match c {
                ' ' | '\r' | '\t' => { self.pos += 1; } 
                '\n' => { tokens.push(Token::Newline); self.pos += 1; }
                ':' => { tokens.push(Token::Colon); self.pos += 1; }
                '=' => {
                    if self.pos + 1 < self.input.len() && self.input[self.pos+1] == '=' {
                        tokens.push(Token::Op("==".to_string()));
                        self.pos += 2;
                    } else {
                        tokens.push(Token::Assign);
                        self.pos += 1;
                    }
                }
                '(' => { tokens.push(Token::LParen); self.pos += 1; }
                ')' => { tokens.push(Token::RParen); self.pos += 1; }
                ',' => { tokens.push(Token::Comma); self.pos += 1; }
                '>' | '<' | '!' => {
                    let next = self.input.get(self.pos + 1);
                    if next == Some(&'=') {
                        tokens.push(Token::Op(format!("{}=", c)));
                        self.pos += 2;
                    } else {
                        tokens.push(Token::Op(c.to_string()));
                        self.pos += 1;
                    }
                }
                '+' | '*' | '/' => { tokens.push(Token::Op(c.to_string())); self.pos += 1; }
                '-' => {
                    if self.pos + 1 < self.input.len() && self.input[self.pos+1] == '>' {
                        tokens.push(Token::Arrow);
                        self.pos += 2;
                    } else {
                        tokens.push(Token::Op("-".to_string()));
                        self.pos += 1;
                    }
                }
                '#' => { while self.pos < self.input.len() && self.input[self.pos] != '\n' { self.pos += 1; } }
                '"' => {
                    self.pos += 1;
                    let mut s = String::new();
                    while self.pos < self.input.len() && self.input[self.pos] != '"' {
                        s.push(self.input[self.pos]);
                        self.pos += 1;
                    }
                    tokens.push(Token::Str(s));
                    self.pos += 1;
                }
                _ if c.is_alphabetic() => {
                    let mut ident = String::new();
                    while self.pos < self.input.len() && (self.input[self.pos].is_alphanumeric() || self.input[self.pos] == '_') {
                        ident.push(self.input[self.pos]);
                        self.pos += 1;
                    }
                    match ident.as_str() {
                        "var" => tokens.push(Token::Var),
                        "val" => tokens.push(Token::Val),
                        "def" => tokens.push(Token::Def),
                        "if" => tokens.push(Token::If),
                        "else" => tokens.push(Token::Else),
                        "pub" => tokens.push(Token::Pub),
                        "return" => tokens.push(Token::Return),
                        "print" => tokens.push(Token::Print),
                        "int" | "float" | "string" => tokens.push(Token::Type(ident)),
                        _ => tokens.push(Token::Ident(ident)),
                    }
                }
                _ if c.is_numeric() => {
                    let mut num = String::new();
                    while self.pos < self.input.len() && self.input[self.pos].is_numeric() {
                        num.push(self.input[self.pos]);
                        self.pos += 1;
                    }
                    tokens.push(Token::Int(num.parse().unwrap()));
                }
                _ => { self.pos += 1; }
            }
        }
        tokens
    }
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 { return; }
    let content = fs::read_to_string(&args[1]).expect("Fail");
    let tokens = Lexer::new(content).tokenize();

    let includes = String::from("// Generated by REDLINE Core\n#include \"stdlib/rl_io.hpp\"\n#include <string>\n\n");
    let mut main_body = String::new();
    let mut i = 0;
    let mut open_braces = 0;

    while i < tokens.len() {
        match &tokens[i] {
            Token::If => {
                let mut condition = String::new();
                i += 1;
                while i < tokens.len() && tokens[i] != Token::Colon {
                    match &tokens[i] {
                        Token::Ident(v) => condition.push_str(v),
                        Token::Int(n) => condition.push_str(&n.to_string()),
                        Token::Op(o) => { condition.push(' '); condition.push_str(o); condition.push(' '); },
                        _ => {}
                    }
                    i += 1;
                }
                main_body.push_str(&format!("    if ({}) {{\n", condition));
                open_braces += 1;
            }
            Token::Else => {
                if open_braces > 0 {
                    main_body.push_str("    } else {\n");
                }
                i += 1;
            }
            Token::Val | Token::Var => {
                let is_const = tokens[i] == Token::Val;
                let name = if let Token::Ident(n) = &tokens[i+1] { n.clone() } else { "".to_string() };
                let t = if let Token::Type(ty) = &tokens[i+3] { if ty == "string" { "std::string" } else { ty } } else { "int" };
                let mut val_str = String::new();
                i += 5;
                while i < tokens.len() && tokens[i] != Token::Newline {
                    match &tokens[i] {
                        Token::Int(n) => val_str.push_str(&n.to_string()),
                        Token::Str(s) => val_str.push_str(&format!("\"{}\"", s)),
                        Token::Ident(v) => val_str.push_str(v),
                        Token::Op(o) => val_str.push_str(o),
                        _ => {}
                    }
                    i += 1;
                }
                let prefix = if is_const { "const " } else { "" };
                main_body.push_str(&format!("    {}{} {} = {};\n", prefix, t, name, val_str));
                
                // Simple scope closing logic: if we just defined something after an if block
                // (Note: For a real language we'd use indentation, but this fixes the immediate crash)
                if open_braces > 0 && i < tokens.len() && tokens[i] == Token::Newline {
                   // We keep it open for now to allow multiple prints in an if
                }
            }
            Token::Print => {
                let arg = match &tokens[i+2] {
                    Token::Str(s) => format!("\"{}\"", s),
                    Token::Ident(n) => n.clone(),
                    Token::Int(n) => n.to_string(),
                    _ => "".to_string(),
                };
                main_body.push_str(&format!("    rl::print({});\n", arg));
                i += 3;
            }
            _ => i += 1,
        }
    }
    
    // Auto-close any open if/else blocks before main ends
    while open_braces > 0 {
        main_body.push_str("    }\n");
        open_braces -= 1;
    }

    print!("{}\nint main() {{\n{}    return 0;\n}}", includes, main_body);
}
