use std::fs;
use std::env;

#[derive(Debug, Clone, PartialEq)]
enum Token {
    Var, Val, Def, Pub, Print, Return,
    Ident(String), Int(i64), Str(String), Type(String),
    Op(char), Arrow, Colon, Assign, LParen, RParen, Comma, Newline,
}

struct Lexer { input: Vec<char>, pos: usize }

impl Lexer {
    fn new(input: String) -> Self { Self { input: input.chars().collect(), pos: 0 } }
    fn tokenize(&mut self) -> Vec<Token> {
        let mut tokens = Vec::new();
        while self.pos < self.input.len() {
            let c = self.input[self.pos];
            match c {
                ' ' | '\r' | '\t' => { self.pos += 1; } 
                '\n' => { tokens.push(Token::Newline); self.pos += 1; }
                ':' => { tokens.push(Token::Colon); self.pos += 1; }
                '=' => { tokens.push(Token::Assign); self.pos += 1; }
                '(' => { tokens.push(Token::LParen); self.pos += 1; }
                ')' => { tokens.push(Token::RParen); self.pos += 1; }
                ',' => { tokens.push(Token::Comma); self.pos += 1; }
                '+' | '*' | '/' => { tokens.push(Token::Op(c)); self.pos += 1; }
                '-' => {
                    if self.pos + 1 < self.input.len() && self.input[self.pos+1] == '>' {
                        tokens.push(Token::Arrow);
                        self.pos += 2;
                    } else {
                        tokens.push(Token::Op(c));
                        self.pos += 1;
                    }
                }
                '#' => { while self.pos < self.input.len() && self.input[self.pos] != '\n' { self.pos += 1; } }
                '"' => {
                    self.pos += 1;
                    let mut s = String::new();
                    while self.pos < self.input.len() && self.input[self.pos] != '"' {
                        s.push(self.input[self.pos]);
                        self.pos += 1;
                    }
                    tokens.push(Token::Str(s));
                    self.pos += 1;
                }
                _ if c.is_alphabetic() => {
                    let mut ident = String::new();
                    while self.pos < self.input.len() && (self.input[self.pos].is_alphanumeric() || self.input[self.pos] == '_') {
                        ident.push(self.input[self.pos]);
                        self.pos += 1;
                    }
                    match ident.as_str() {
                        "var" => tokens.push(Token::Var),
                        "val" => tokens.push(Token::Val),
                        "def" => tokens.push(Token::Def),
                        "pub" => tokens.push(Token::Pub),
                        "return" => tokens.push(Token::Return),
                        "print" => tokens.push(Token::Print),
                        "int" | "float" | "string" => tokens.push(Token::Type(ident)),
                        _ => tokens.push(Token::Ident(ident)),
                    }
                }
                _ if c.is_numeric() => {
                    let mut num = String::new();
                    while self.pos < self.input.len() && self.input[self.pos].is_numeric() {
                        num.push(self.input[self.pos]);
                        self.pos += 1;
                    }
                    tokens.push(Token::Int(num.parse().unwrap()));
                }
                _ => { self.pos += 1; }
            }
        }
        tokens
    }
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 { return; }
    let content = fs::read_to_string(&args[1]).expect("Fail");
    let tokens = Lexer::new(content).tokenize();

    let includes = String::from("// Generated by REDLINE Core\n#include \"stdlib/rl_io.hpp\"\n#include <string>\n\n");
    let mut functions = String::new();
    let mut main_body = String::new();
    let mut i = 0;

    while i < tokens.len() {
        match &tokens[i] {
            Token::Pub | Token::Def => {
                if tokens[i] == Token::Pub { i += 1; }
                if i < tokens.len() && tokens[i] == Token::Def {
                    let name = if let Token::Ident(n) = &tokens[i+1] { n.clone() } else { "".to_string() };
                    i += 3; // skip def, name, (
                    
                    let mut params = Vec::new();
                    while i < tokens.len() && tokens[i] != Token::RParen {
                        if let Token::Ident(p_n) = &tokens[i] {
                            let p_t = if let Token::Type(t) = &tokens[i+2] { if t == "string" { "std::string" } else { t } } else { "int" };
                            params.push(format!("{} {}", p_t, p_n));
                            i += 3;
                        }
                        if i < tokens.len() && tokens[i] == Token::Comma { i += 1; }
                    }
                    i += 1; // skip )

                    // Check for Arrow -> Type
                    let mut ret_type = "void".to_string();
                    if i < tokens.len() && tokens[i] == Token::Arrow {
                        if let Token::Type(t) = &tokens[i+1] {
                            ret_type = if t == "string" { "std::string".to_string() } else { t.clone() };
                            i += 2;
                        }
                    }

                    functions.push_str(&format!("{} {}({}) {{\n", ret_type, name, params.join(", ")));

                    // Skip until we find the Colon or Newline to start the body
                    while i < tokens.len() && tokens[i] != Token::Newline && tokens[i] != Token::Colon { i += 1; }

                    // Collect body logic
                    while i < tokens.len() && !matches!(tokens[i], Token::Def | Token::Pub | Token::Val | Token::Var) {
                        match &tokens[i] {
                            Token::Return => {
                                let mut val = String::new();
                                i += 1;
                                while i < tokens.len() && tokens[i] != Token::Newline {
                                    match &tokens[i] {
                                        Token::Int(n) => val.push_str(&n.to_string()),
                                        Token::Ident(v) => val.push_str(v),
                                        Token::Op(o) => val.push(*o),
                                        _ => {}
                                    }
                                    i += 1;
                                }
                                functions.push_str(&format!("    return {};\n", val));
                            }
                            Token::Print => {
                                let arg = if let Token::Str(s) = &tokens[i+2] { format!("\"{}\"", s) } else if let Token::Ident(n) = &tokens[i+2] { n.clone() } else { "".to_string() };
                                functions.push_str(&format!("    rl::print({});\n", arg));
                                i += 3;
                            }
                            _ => i += 1,
                        }
                    }
                    functions.push_str("}\n\n");
                }
            },
            Token::Val | Token::Var => {
                let is_const = tokens[i] == Token::Val;
                let name = if let Token::Ident(n) = &tokens[i+1] { n.clone() } else { "".to_string() };
                let t = if let Token::Type(ty) = &tokens[i+3] { if ty == "string" { "std::string" } else { ty } } else { "int" };
                let mut val_str = String::new();
                i += 5;
                while i < tokens.len() && tokens[i] != Token::Newline {
                    match &tokens[i] {
                        Token::Int(n) => val_str.push_str(&n.to_string()),
                        Token::Str(s) => val_str.push_str(&format!("\"{}\"", s)),
                        Token::Ident(v) => {
                            val_str.push_str(v);
                            if i + 1 < tokens.len() && tokens[i+1] == Token::LParen {
                                val_str.push('(');
                                i += 2;
                                while i < tokens.len() && tokens[i] != Token::RParen {
                                    match &tokens[i] {
                                        Token::Ident(an) => val_str.push_str(an),
                                        Token::Int(av) => val_str.push_str(&av.to_string()),
                                        _ => {}
                                    }
                                    if i+1 < tokens.len() && tokens[i+1] == Token::Comma { val_str.push_str(", "); i += 1; }
                                    i += 1;
                                }
                                val_str.push(')');
                            }
                        },
                        Token::Op(o) => val_str.push(*o),
                        _ => {}
                    }
                    i += 1;
                }
                let prefix = if is_const { "const " } else { "" };
                main_body.push_str(&format!("    {}{} {} = {};\n", prefix, t, name, val_str));
            },
            Token::Print => {
                let arg = if let Token::Str(s) = &tokens[i+2] { format!("\"{}\"", s) } else if let Token::Ident(n) = &tokens[i+2] { n.clone() } else if let Token::Int(n) = &tokens[i+2] { n.to_string() } else { "".to_string() };
                main_body.push_str(&format!("    rl::print({});\n", arg));
                i += 3;
            }
            _ => i += 1,
        }
    }
    print!("{}{}\nint main() {{\n{}    return 0;\n}}", includes, functions, main_body);
}
