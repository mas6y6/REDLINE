# ðŸŸ¥ REDLINE v0.3 Documentation

REDLINE is a high-performance, transpiled systems language designed to be as readable as Python but as fast as C++.

## 1. Variables & Constants

REDLINE distinguishes between data that changes and data that stays the same. This allows the compiler to optimize memory.

| Keyword | Meaning | C++ Translation |
|---|---|---|
| `val` | Immutable (Constant). Cannot be changed once set. | `const` |
| `var` | Mutable (Variable). Can be updated later. | (Standard variable) |

Syntax:
```redline
val name: string = "Ace"
var health: int = 100
var pi: float = 3.14
```

## 2. Data Types

REDLINE is strictly typed, meaning the compiler ensures you don't accidentally treat a number like a word.

*   `int`: Whole numbers (e.g., `10`, `-5`).
*   `float`: Decimal numbers (e.g., `10.5`, `3.14`).
*   `string`: Text wrapped in double quotes (e.g., `"Redline"`).

## 3. Functions

Functions in REDLINE use a modern "Arrow" syntax to show what they return.

Syntax:
```redline
def name(param: type) -> return_type:
    # Logic here
    return value
```

*   `->`: Points to the type of data the function gives back.

Example:
```redline
def add(a: int, b: int) -> int:
    val result: int = a + b
    return result

val sum: int = add(5, 3)
print(sum)
```

## 4. Control Flow (Decision Making)

REDLINE uses `if` and `else` for logic. It uses C-style comparison operators but Python-style structure.

Comparison Operators:

*   `==` (Equal to)
*   `!=` (Not equal to)
*   `>` (Greater than)
*   `<` (Less than)
*   `>=` / `<=` (Greater/Less than or equal)

Example:
```redline
if speed > 200:
    print("Turbo Active")
else:
    print("Cruising")
```

## 5. Standard Output

The built-in `print` command handles communication with the console. It is powered by the `rl_io.hpp` library in your `stdlib` folder.

```redline
print("System Initialized")
print(42)
```

## 6. The Compiler Pipeline

Understanding how your code turns into a program helps with debugging.

1.  **.rl File**: You write your logic here.
2.  **Lexer (`lexer.rs`)**: The first stage of the Rust "Brain". It reads your code and breaks it down into a series of "tokens" (like keywords, identifiers, and operators).
3.  **Parser (`parser.rs`)**: Takes the tokens and builds a structured representation of the code, called an Abstract Syntax Tree (AST). Uses precedence climbing for proper operator handling.
4.  **Code Generator (`codegen.rs`)**: The final stage of the "Brain". It walks through the AST and translates it into C++ code.
5.  **`output.cpp`**: The intermediate C++ file generated by the code generator.
6.  **G++ Compiler**: Turns the C++ into machine code.
7.  **Executable**: A lightning-fast file you can run directly.

## 7. Error Handling

The REDLINE compiler attempts to provide helpful error messages when something goes wrong. If you make a syntax error, the compiler will report the error with the file, line, and column number to help you find the mistake quickly.

Example Error:
```
Lexer Error: Unknown character: @ at line 2, column 1
Parser Error: Expected a primary expression, got Token::Int(42)
```

## 8. Standard Library

### rl_io.hpp
Provides input/output functionality:
- `print()`: Print values to stdout

### rl_math.hpp
Provides mathematical functions:
- `abs()`: Absolute value
- `sqrt()`: Square root
- `pow()`: Power function
- `sin()`, `cos()`, `tan()`: Trigonometric functions
- `log()`, `log10()`: Logarithmic functions
- `exp()`: Exponential function
- `floor()`, `ceil()`, `round()`: Rounding functions
- `min()`, `max()`: Minimum and maximum
- Constants: `PI`, `E`

## 9. Future Keywords (Roadmap)

These are keywords reserved for our next updates:

*   `while` / `for`: For loops.
*   `input`: For taking user keyboard data.
*   `import`: For loading other `.rl` files.
*   `pub`: For making functions accessible globally.

## 10. Contributing

This documentation is a work in progress. If you find any errors or want to improve it, please feel free to open an issue or pull request!
